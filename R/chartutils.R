#' ErrorIfNotEnoughData
#'
#' Returns an error if there is not enough data for charting.
#' @param x The data to be plotted.
#' @param require.tidy The data is assumed to be a numeric vector, matrix, array, or data frame.
#' @export
ErrorIfNotEnoughData <- function(x, require.tidy = TRUE)
{
    .stop <- function()
        { stop("There is not enough data to create a plot.") }
    .possiblyTidy <- function(x)
        {is.numeric(x) || is.matrix(x) || is.data.frame(x) || is.array(x)}
    .noData <- function(x)
        {NROW(x) == 0 || NCOL(x) == 0 || all(is.na(x))}

    if (!require.tidy && is.list(x))
        x <- x[[1]]
    if (require.tidy && !.possiblyTidy(x))
        stop("The data is not in an appropriate format.")
    if (.noData(x))
        .stop()
}

# hovertemplate is preferrable to hoverinfo because it allows better control
# of formatting. Specifically, we can re-order the x/y and control separators
# and newlines. But the format is slightly more complex
setHoverTemplate <- function(i, axis, chart.matrix, is.bar = FALSE, hide.category = FALSE)
{
    if (hide.category)
    {
        # This is typically because the category info cannot be accurately repeated
        formatStr <- if (is.bar) "%{x}" else "%{y}"

    } else
    {
        formatStr <- if (axis$type == "category") "%{x}: %{y}"
                     else                         "(%{x}, %{y})"
        if (is.bar && axis$type == "category")
            formatStr <- "%{y}: %{x}"
    }

    nameStr <- if (ncol(chart.matrix) == 1 && colnames(chart.matrix)[1] %in% c("Series.1", "Series 1")) ""
               else colnames(chart.matrix)[i]
    formatStr <- paste0(formatStr, "<extra>", nameStr, "</extra>")
    return(formatStr)
}

setHoverText <- function(axis, chart.matrix, is.bar = FALSE)
{
    formatStr <- if (axis$type == "category") "text+y"
                 else                         "x+y"
    if (is.bar && axis$type == "category")
        formatStr <- "text+x"

    if (ncol(chart.matrix) > 1)
        formatStr <- paste0("name+", formatStr)

    return(formatStr)
}



minPosition <- function(x, n = 1)
{
    if (is.character(x))
        return(rep(x[1], n))
    else if (is.factor(x))
        return(rep(levels(x)[1], n))
    else
        return(rep(min(x, na.rm=T), n))
}

#' Checks input data and converts it into a matrix for charting
#'
#' Converts input data into a matrix with 2 dimensions
#'   and row and columns names which can be used for charting.
#' @param x Input in the form of vector, matrix, array, time-series object
#'   or a Q table. If input is a Q table, then only the first statistic is returned
#' @param assign.col.names Whether to assign column names. This defaults to true,
#'   It is set to false (for example in \code{Heat}) because the columns do not
#'   make up separate series.
#' @return Numeric matrix with the first statistic in \code{x}.
#' @importFrom flipU CopyAttributes
#' @noRd
checkMatrixNames <- function(x, assign.col.names = TRUE)
{
    # Check for special case where x is a time-series object
    tInfo <- attr(x, "tsp")
    if (length(tInfo) == 3)
    {
        t.seq <- seq(from = tInfo[1], to = tInfo[2], by = 1/tInfo[3])
        x <- as.matrix(x)
        rownames(x) <- t.seq
        return(x)
    }

    # Convert into a matrix format
    old.names <- c(dimnames(x), NA, NA) # ensure there are at least 2 elements
    new.x <- if (length(dim(x)) == 3) matrix(x, nrow(x), ncol(x), dimnames = old.names[1:2]) # explicitly specify dimensions
             else as.matrix(suppressWarnings(AsTidyTabularData(x))) # handles 1d data + statistic properly

    # Try to convert character matrix to numeric
    # This may occur in Q-tables with a character statistic (e.g. 'Column Comparisons')
    old.dim <- dim(new.x)
    old.names <- dimnames(new.x)
    if (is.character(new.x))
    {
        new.x <- as.numeric(new.x)
        dim(new.x) <- old.dim
        dimnames(new.x) <- old.names
    }
    
    # Many of the charts use the statistic attribute
    x <- CopyAttributes(new.x, x)

    # Assign row/column names if missing 
    if (is.null(rownames(x)))
        rownames(x) <- 1:nrow(x)
    if (is.null(colnames(x)) && assign.col.names)
        colnames(x) <- sprintf("Series %d", 1:ncol(x))
    if (any(duplicated(rownames(x))))
        stop("Row names of the input table must be unique.")
    return(x)
}

checkTableList <- function(y, trend.lines)
{
    num.tables <- length(y)
    y.names <- rep("", num.tables)
    used.names <- c()
    for (i in 1:num.tables)
    {
        if (is.null(attr(y[[i]], "name")))
        {
            attr(y[[i]], "name") <- as.character(i)
            used.names <- c(used.names, i)
        }
        y.names[i] <- attr(y[[i]], "name")[1]
    }
    if (!trend.lines && length(used.names) > 0)
        warning(sprintf("Tables have been automatically assigned names '%s'. You can name tables using R code: 'attr(table.name, \"name\") <- \"Description\"'", paste(used.names, collapse="', '")))
    if (any(duplicated(y.names)) & !trend.lines)
        warning(sprintf("Tables have duplicate names: '%s'. Points from duplicated tables cannot be distinguised.", paste(y.names[duplicated(y.names)], collapse = "', '")))

    # Check tables match - order of rows will match first table
    r.names <- rownames(y[[1]])
    c.names <- colnames(y[[1]])
    if (!is.null(r.names) && any(duplicated(r.names)) && length(y) > 1)
        stop("Row names of tables must be unique or NULL for multiple tables to be plotted but are duplicated.")

    if (num.tables > 1) {
        for (i in 2:num.tables)
        {
            if (!setequal(r.names, rownames(y[[i]])))
                stop(sprintf("Tables should have identical row names but table '%s' differs from table '%s'.",
                             y.names[i], y.names[1]))
            if (!setequal(c.names, colnames(y[[i]])))
                stop(sprintf("Tables should have identical column names but table '%s' differs from table '%s'.",
                             y.names[i], y.names[1]))
            if (!is.null(r.names))
                y[[i]] <- y[[i]][r.names, , drop = FALSE]
            if (!is.null(c.names))
                y[[i]] <- y[[i]][, c.names, drop = FALSE]
        }
    }
    return(y)
}


#' Returns range of axis or vector in format readable for plotly
#'
#' @param axis If \code{axis} object is provided and \code{range} is
#'   specified in it (i.e. not \code{auto.range}), then this range will
#'   be returned
#' @param axisFormat This is the output of \code{formatLabels}. This object
#'   contains information if the axis is a date.
#' @param x If \code{axis$range} is not provided, and \code{axisFormat} does
#'   not contain dates, then range is determined
#'   from the range of the data \code{x}. Offsets are added so that
#'   bar and column charts are not truncated
#' @importFrom flipTime AsDateTime
#' @noRd
getRange <- function(x, axis, axisFormat)
{
    tozero <- FALSE
    range <- NULL
    if (!is.null(axis) && !any(is.na(axis$range)))
    {
        # in setAxis, date ranges must be a character, but when we copy an
        # axis to add data labels, we need it as a numeric
        if (axis$type == "date" && is.character(axis$range))
            range <- as.numeric(AsDateTime(axis$range)) * 1000
        else
            range <- axis$range

        if (is.null(axis$range) && axis$rangemode == "tozero")
            tozero <- TRUE
    }

    # Use axis type if numeric or categorical specified
    # For date axis, we do some more checking
    if (is.null(range) && !is.null(axis) && !is.null(axis$type))
    {
        if (axis$type == "numeric")
            range <- calcRangeNumeric(x) 
        else if (axis$type == "category") 
            range <- calcRangeCategorical(x)

        if (isTRUE(axis$autorange == "reversed"))
            range <- rev(range)
    }

    # Unspecified axis type or with a date range
    if (is.null(range))
    {
        # In most cases axisFormat$ymd is specified if axis is a date
        if (!is.null(axisFormat) && length(axisFormat$ymd) >= 2)
        {
            tmp.dates <- sort(unique(as.numeric(axisFormat$ymd))) * 1000
            diff <- min(diff(tmp.dates), na.rm = TRUE)
            range <- range(tmp.dates) + c(-1, 1) * diff
        }
        else if (is.numeric(x))
        {
            range <- calcRangeNumeric(x)
            if (tozero)
                range <- c(min(0, range[1]), max(0, range[2]))
        }
        else if (all(!is.na(suppressWarnings(AsDateTime(x, on.parse.failure = "silent")))) &&
                 !(!is.null(axis) && axis$type == "numeric"))
        {
            tmp.dates <- sort(unique(as.numeric(AsDateTime(x)))) * 1000
            diff <- min(diff(tmp.dates), na.rm = TRUE)
            range <- range(tmp.dates) + c(-1, 1) * diff

        }
        else if (all(!is.na(suppressWarnings(as.numeric(x)))))
        {
            range <- calcRangeNumeric(x)
            if (tozero)
                range <- c(min(0, range[1]), max(0, range[2]))
        }
        else
            range <- calcRangeCategorical(x)

        if (!is.null(axis) && axis$autorange == "reversed")
            range <- rev(range)
    }
    range
}

calcRangeNumeric <- function(x, offset = 0.5)
{
    tmp <- as.numeric(unique(x))
    diff <- if (length(x) == 1) 1
            else abs(min(diff(sort(tmp)), na.rm = TRUE))
    return(range(tmp) + c(-offset, offset) * diff)
}

calcRangeDate <- function(x)
{


}

calcRangeCategorical <- function(x)
{
    tmp <- unique(x)
    return(c(-0.5, length(tmp)-0.5))
}


isReversed <- function(axis)
{
    if (is.null(axis$range))
        return(axis$autorange == "reversed")
    return(xor(axis$range[1] > axis$range[2], axis$autorange == "reversed"))
}


#' Construct line of best fit
#'
#' @param x Independent (predictor) data for fitting (this is actually
#'   the y-axis in bar charts). May be vector of numeric, dates or factor.
#' @param y Dependent (predicted data). This must be a numeric vector.
#' @param fit.type May be \code{Smooth}, which creates a loess smooth, or
#'   any other value will use a \code{Linear} regression to create the line
#'   of best fit
#' @param axis.type The axis type of the dependent axis. This is used
#'   to provide extra information about how to display the \code{x} variable.
#' @param ignore.last Whether to ignore the last observation in \code{x}
#'   and \code{y}.
#' @param warning.prefix Used by small multiples for nice warning messages.
#' @importFrom stats supsmu filter
#' @importFrom mgcv gam
#' @noRd
fitSeries <- function(x, y, fit.type, ignore.last, axis.type, CI.show = FALSE,
                      fit.window.size = 3, warning.prefix = "")
{
    if (!is.numeric(y))
    {
        warning("Line of best fit cannot handle non-numeric y-values.")
        return(list(x = NULL, y = NULL))
    }

    tmp.is.factor <- axis.type != "numeric"
    if (tolower(axis.type) == "category" && !is.factor(x))
        x0 <- (1:length(x)) - 1
    else if (tmp.is.factor)
        x0 <- suppressWarnings(AsNumeric(x, binary = FALSE))
    else
        x0 <- as.numeric(x)
    tmp.dat <- data.frame(xorig = x, x = x0, y = y)
    if (ignore.last)
        tmp.dat <- tmp.dat[-which.max(tmp.dat$x),]
    if (nrow(tmp.dat) < 2)
    {
        warning(warning.prefix, "Not enough data to constuct line of best fit.")
        return(list(x = NULL, y = NULL))
    }
    ord <- order(tmp.dat$x)
    tmp.dat <- tmp.dat[ord,]

    if (grepl("(friedman|super|supsmu|moving average)", fit.type, perl = TRUE, ignore.case = TRUE))
    {
        if (CI.show)
            warning("Confidence intervals cannot be computed for trend lines of this type.")
        if (!grepl("moving average", fit.type, perl = TRUE, ignore.case = TRUE))
        {
            ind.na <- which(!is.finite(tmp.dat$x) | !is.finite(tmp.dat$y))
            if (length(ind.na) > 0)
                tmp.dat <- tmp.dat[-ind.na,]
        }
        indU <- which(!duplicated(tmp.dat$x))
        if (length(indU) < nrow(tmp.dat))
            warning(warning.prefix, "Multiple points at the same x-coordinate ignored for estimating line of best fit.\n")
        if (grepl("moving average", fit.type, perl = TRUE, ignore.case = TRUE))
        {
            if (!is.finite(fit.window.size) && fit.window.size <= 0)
                stop("Moving average must have a positive window size")
            if (length(indU) <= fit.window.size)
            {
                warning("Trend line could not be shown. The length of the data series ",
                        "must be larger than the window size (", fit.window.size, ")")
                return(list(x = NULL, y = NULL))
            }
            tmp.gaps <- unique(diff(tmp.dat$x[indU]))
            if (any(tmp.gaps > min(tmp.gaps) * 1.2)) # allow some variation for dates
                warning("Moving averages do not account for the different intervals between values.")
            if (grepl("center|centre", fit.type, perl = TRUE, ignore.case = TRUE))
                tmp.avg <- rev(filter(tmp.dat$y[rev(indU)], rep(1/fit.window.size, fit.window.size), sides = 2))
            else
                tmp.avg <- filter(tmp.dat$y[indU], rep(1/fit.window.size, fit.window.size), sides = 1)
            return(list(x = tmp.dat$xorig[indU], y = as.numeric(tmp.avg)))
        }
        else
        {
            tmp.fit <- suppressWarnings(try(supsmu(tmp.dat$x[indU], tmp.dat$y[indU]), silent = TRUE))
            if (!inherits(tmp.fit, "try-error"))
                return(list(x = tmp.dat$xorig[indU], y = tmp.fit$y))
        }
    }
    else if (grepl("(smooth|loess)", fit.type, ignore.case = TRUE) && nrow(tmp.dat) > 7)
        tmp.fit <- suppressWarnings(try(loess(y~x, data = tmp.dat), silent = TRUE))
    else if (grepl("(cubic|spline|gam)", fit.type, ignore.case = TRUE))
        tmp.fit <- suppressWarnings(try(gam(y~s(x, bs = "cr"), data = tmp.dat), silent = TRUE))
    else
        tmp.fit <- suppressWarnings(try(lm(y~x, data=tmp.dat), silent = TRUE))

    if (inherits(tmp.fit, "try-error"))
    {
        warning(warning.prefix, "Could not fit trend line using ", fit.type, ".")
        return(list(x = NULL, y = NULL))
    }
    x.fit <- if (tmp.is.factor) tmp.dat$x
             else seq(from = min(x0, na.rm = TRUE), to = max(x0, na.rm = TRUE), length = 100)
    if (!tmp.is.factor && max(x.fit) < max(tmp.dat$x))
        x.fit <- c(x.fit, max(tmp.dat$x))
    y.fit <- if ("gam" %in% class(tmp.fit)) suppressWarnings(try(predict(tmp.fit, data.frame(x = x.fit), se = CI.show, type = "response")))
             else                           suppressWarnings(try(predict(tmp.fit, data.frame(x = x.fit), se = CI.show)))
    if (tmp.is.factor)
        x.fit <- tmp.dat$xorig
    if (CI.show)
    {
        lb <- as.numeric(y.fit$fit - (1.96 * y.fit$se))
        ub <- as.numeric(y.fit$fit + (1.96 * y.fit$se))
        return(list(x = x.fit, y = y.fit$fit, lb = lb, ub = ub))
    }
    return(list(x = x.fit, y = y.fit))
}

# This function deals with both logical or string inputs
setShowLegend <- function(legend.show, num.series = 2)
{
    auto.show <- num.series > 1

    # Default response is to only show legend if it there is more than 1 series
    if (isTRUE(legend.show) || is.na(legend.show) || grepl("Auto", legend.show))
        return(auto.show)
    if (isTRUE(legend.show == FALSE))
        return(FALSE)

    # If legend.show is not boolean, check for string inputs
    # Note that legend is shown even if there is only 1 series
    # For legacy reasons, the boolean inputs do not give the same result.
    if (grepl(legend.show, "Show"))
        return(TRUE)
    if (grepl(legend.show, "Hide"))
        return(FALSE)

    # If legend.show is unknown, then return default
    return(auto.show)
}

setLegend <- function(type, font, ascending, fill.color, fill.opacity, border.color, border.line.width,
                      x.pos = NULL, y.pos = NULL, reversed = FALSE, orientation = 'Vertical', y2.show = FALSE)
{
    if (tolower(substr(orientation, 1, 1)) == "h")
        orientation <- "h"
    else
        orientation <- "v"

    if (y2.show)
    {
        if (is.null(x.pos))
            x.pos <- if (orientation == "v") 1.15 else 0.5
        if (is.null(y.pos))
            y.pos <- if (orientation == "v") 1.0 else -0.3
    } else 
    {
        if (is.null(x.pos))
            x.pos <- if (orientation == "v") 1.02 else 0.5
        if (is.null(y.pos))
            y.pos <- if (orientation == "v") 1.0 else -0.2
    }

    if (is.na(ascending))
        ascending <- !(grepl("Stacked", type) && !reversed) || grepl("Stacked Bar", type)
    order <- if (!ascending) "reversed" else "normal"
    return(list(bgcolor = toRGB(fill.color, alpha=fill.opacity),
            bordercolor = border.color,
            borderwidth = border.line.width,
            orientation = orientation,
            font = font,
            xanchor = if (x.pos == 0.5) "center" else "left",
            yanchor = if (y.pos > 1.0) "bottom" else "auto",
            y = max(-2, min(3, y.pos)),
            x = max(-2, min(3, x.pos)),
            traceorder = order))
}

#' @importFrom flipTime AsDateTime
getAxisType <- function(labels, format)
{
    d3.type <- d3FormatType(format)

    if (d3.type == "category")
        return("category")

    if (d3.type == "date")
    {
        if (inherits(labels, "Date") || inherits(labels, "POSIXt") || inherits(labels, "POSIXct"))
            return("date")
        ymd <- suppressWarnings(AsDateTime(as.character(labels), on.parse.failure = "silent"))
        if (!any(is.na(ymd)))
            return("date")
    }
    if (d3.type == "numeric")
    {
        if (!any(is.na(suppressWarnings(as.numeric(gsub(",", "", labels))))))
            return("numeric")
    }

    # Try to find default format based only on labels
    if (!any(is.na(suppressWarnings(as.numeric(gsub(",", "", labels))))))
        return("numeric")
    ymd <- suppressWarnings(AsDateTime(labels, on.parse.failure = "silent"))
    if (all(!is.na(ymd)) && length(ymd) > 1)
        return("date")
    else
        return("category")
}

# This is only used in labeledscatter
convertAxis <- function(values, axis.type)
{
    if (axis.type == "date")
        return(AsDateTime(values, on.parse.failure = "silent"))
    if (axis.type == "category")
    {
        # Do not use flipTransformations::Factor because we don't want to aggregate by QDate
        if (inherits(values, "factor"))
            return(values)
        return(factor(values, levels = unique(as.character(values))))
    }
    if (axis.type == "numeric")
        return(as.numeric(values))
    # not sure what type this is?
        return(as.vector(values))
}

d3FormatType <- function(format)
{
    if (is.null(format) || is.na(format) || format == "")
        return("")
    if (format == "Category")
        return("category")

    if (grepl("%[aAbBcdefHIJmMLpQsSuUVwWxXyYz]", format))
        return("date")
    else
        return("numeric")
}

#' @importFrom flipTime AsDateTime
#' @noRd
formatLabels <- function(dat, type, label.wrap, label.wrap.nchar, x.format, y.format)
{
    is.bar <- grepl("Bar", type, fixed=T)
    if (is.matrix(dat))
    {
        x.labels <- rownames(dat)
        y.labels <- NULL

        x.axis.type <- "numeric"
        y.axis.type <- "numeric"
        if (!is.bar)
            x.axis.type <- getAxisType(x.labels, x.format)
        else
            y.axis.type <- getAxisType(x.labels, x.format)
    }
    else
    {
        x.labels <- unique(dat[[1]])
        y.labels <- unique(dat[[2]])
        x.axis.type <- getAxisType(x.labels, x.format)
        y.axis.type <- getAxisType(y.labels, y.format)
    }

    # labels are only processed for independent x-axis (or y-axis in bar charts)
    # the other axis is always numeric
    labels <- x.labels
    axis.type <- if (is.bar) y.axis.type else x.axis.type
    if (axis.type == "date")
    {
        ymd <- AsDateTime(labels, on.parse.failure = "silent")
        n.dup <- sum(duplicated(ymd))
        if (n.dup > 0)
            warning("Date axis has ", n.dup, " duplicated values. There may have been error parsing dates.")
        labels <- ymd
    }
    else
    {
        ymd <- NULL
        if (is.character(labels))
            labels <- autoFormatLongLabels(labels, label.wrap, label.wrap.nchar)
    }
    return(list(ymd = ymd, labels = labels, labels.on.x = !is.bar,
                x.axis.type = x.axis.type, y.axis.type = y.axis.type))
}

getDateAxisRange <- function(label.dates, new.range = NULL)
{
    if (length(new.range) == 2)
        return(as.character(new.range))

    tmp.dates <- as.numeric(label.dates)
    diff <- min(abs(diff(sort(unique(tmp.dates)))), na.rm = TRUE)

    # Always return date-ranges as characters since there
    # seems to be more problems with using milliseconds since plotly v4.8.0
    range <- as.character(range(label.dates) + c(-1,1) * ceiling(0.5 * diff))
    return(as.character(range))
}

setAxis <- function(title, side, axisLabels, titlefont,
                    linecolor, linewidth, gridwidth, gridcolor,
                    ticks, tickfont, tickangle, ticklen, tickdistance,
                    tickformatmanual, tickprefix, ticksuffix, tickshow,
                    show.zero, zero.line.width, zero.line.color,
                    hovertext.format.manual, labels = NULL, num.series = 1,
                    with.bars = FALSE)
{
    axis.type <- if (side %in% c("bottom", "top")) axisLabels$x.axis.type else axisLabels$y.axis.type
    has.line <- !is.null(linewidth) && linewidth > 0
    if (!tickshow)
        tickfont$size <- 0

    if (!is.null(labels) && any(!is.na(labels)) && any(nchar(labels) > 0) &&
         is.null(tickangle) && side %in% c("bottom", "top"))
    {
        lab.nchar <- max(c(0, nchar(unlist(strsplit(split = "<br>", as.character(labels))))), na.rm = TRUE)
        tickangle <- if ((!axis.type %in% c("numeric", "linear", "date")) && lab.nchar > 2 &&
                        length(labels) * num.series * lab.nchar > 50) 90
                     else 0
    }

    autorange <- ticks$autorange
    range <- ticks$range
    day.len <- 60 * 60 * 24 * 1000
    tickmode <- ticks$mode
    tick0 <- NULL
    tickformat <- checkD3Format(tickformatmanual, axis.type)
    hoverformat <- checkD3Format(hovertext.format.manual, axis.type, "Hovertext")

    if ((!axisLabels$labels.on.x) && side %in% c("left","right"))
    {
        autorange <- FALSE
        if (axis.type == "date")
        {
            range <- rev(getDateAxisRange(axisLabels$ymd, range))

            # Override default tick positions if there are only a few bars
            if (with.bars && length(axisLabels$labels) <= 10 && length(axisLabels$labels) >= 2)
            {
                tmp.n <- length(axisLabels$ymd)
                tmp.dist <- (difftime(axisLabels$ymd[tmp.n], axisLabels$ymd[1], units = "secs"))/
                                (tmp.n - 1)
                use.auto.ticks <- TRUE
                if (tmp.dist <= 86400) # days
                    use.auto.ticks <- FALSE
                else if (tmp.dist <= 0.9 * 31536000) # whether to show day
                    use.auto.ticks <- all(as.numeric(format(axisLabels$ymd, "%d")) == 1)
                else # whether to show month/day
                    use.auto.ticks <- all(as.numeric(format(axisLabels$ymd, "%j")) == 1)

                if (!use.auto.ticks && difftime(max(axisLabels$ymd), min(axisLabels$ymd), units = "secs") < 11 * tmp.dist)
                {
                    tickmode <- "linear"
                    tick0 <- axisLabels$ymd[1]
                    tickdistance <- tmp.dist * 1000
                }
            }
        }
        else if (axis.type == "numeric")
        {
            # Create a fake axis to specify axis type
            if (is.null(range))
                range <- calcRangeNumeric(axisLabels$labels)
            range <- rev(range)
            if (show.zero)
            {
                range[2] <- min(range[2], 0)
                range[1] <- max(range[1], 0)
            }
        }
        else
            range <- c(length(axisLabels$labels) - 0.5, -0.5)
        if (ticks$autorange != "reversed")
            range <- rev(range)
    }
    else if (axis.type == "date" && length(axisLabels$ymd) >= 2)
    {
        autorange <- FALSE
        rev <- length(range) == 2 && range[2] < range[1]
        range <- getDateAxisRange(axisLabels$ymd, range)
        if (ticks$autorange == "reversed" || rev)
            range <- rev(range)

        # Override default tick positions if there are only a few column bars
        # and if there will not be too many ticks
        if (with.bars && length(axisLabels$labels) <= 10)
        {
            tmp.n <- length(axisLabels$ymd)
            tmp.dist <- (difftime(axisLabels$ymd[tmp.n], axisLabels$ymd[1], units = "secs"))/
                            (tmp.n - 1)
            use.auto.ticks <- TRUE
            if (tmp.dist <= 86400) # days
                use.auto.ticks <- FALSE
            else if (tmp.dist <= 0.9 * 31536000) # whether to show day
                use.auto.ticks <- all(as.numeric(format(axisLabels$ymd, "%d")) == 1)
            else # whether to show month/day
                use.auto.ticks <- all(as.numeric(format(axisLabels$ymd, "%j")) == 1)

            if (!use.auto.ticks && difftime(max(axisLabels$ymd), min(axisLabels$ymd), units = "secs") < 11 * tmp.dist)
            {
                # ensure that ticks are shown at each bar
                tickmode <- "linear"
                tick0 <- axisLabels$ymd[1]
                tickdistance <- tmp.dist * 1000
            }
        }
    }
    else if (axis.type == "category" && !is.null(axisLabels$ymd))
    {
        if (!is.null(range))
        {
            rev <- range[1] > range[2]
            range <- calcRangeCategorical(as.character(axisLabels$ymd))
            if (rev)
                range <- rev(range)
        }
    }

    rangemode <- "normal"
    if (axis.type == "numeric" && show.zero)
        rangemode <- "tozero"
    if (gridwidth == 0)
        zero.line.color <- rgb(1, 1, 1, alpha = 0) # invisible

    # Specify max number of ticks
    nticks <- NULL
    independ.axis <- side %in% c("top", "bottom") == axisLabels$labels.on.x
    if (axis.type != "category" && tickmode == "auto" && independ.axis &&
        !(length(axisLabels$labels) == 1 && is.numeric(axisLabels$labels)))
        nticks <- min(length(axisLabels$labels) + 1, 11)

    if (sum(nchar(title)) > 0)
        title <- list(text = title, font = titlefont)
    else
        title <- NULL

    return (list(title = title,
                 side = side, type = axis.type,
                 tickfont = tickfont,
                 showline = has.line, linecolor = linecolor,
                 linewidth = if (!has.line) NULL else linewidth,
                 showgrid = gridwidth > 0, gridwidth = gridwidth,
                 gridcolor = gridcolor, tickmode = tickmode, nticks = nticks,
                 tickvals = ticks$tickvals, ticktext = ticks$ticktext,
                 ticks = if (has.line) "outside" else "", tickangle = tickangle,
                 ticklen = ticklen, tickcolor = linecolor, tickfont = tickfont,
                 dtick = tickdistance, tickformat = tickformat, tick0 = tick0,
                 tickprefix = tickprefix, ticksuffix = ticksuffix,
                 hoverformat = hoverformat, layer = "below traces",
                 autorange = autorange, range = range, rangemode = rangemode,
                 zeroline = show.zero, zerolinewidth = zero.line.width,
                 zerolinecolor = zero.line.color,
                 showexponent="all", showtickprefix=TRUE, showticksuffix=TRUE,
                 showticklabels=tickshow))
}


fontAspectRatio <- function(font)
{
    if (length(font) == 0)
        return (0.54)
    font <- as.character(font)
    font.asp <- switch(tolower(font),
                          'arial'= 0.54,
                          'arial black' = 0.63,
                          'century gothic' = 0.61,
                          'courier new' = 0.63,
                          'impact' = 0.48,
                          'open sans' = 0.45,
                          'times new roman' = 0.45,
                          'tahoma' = 0.52,
                          'trebuchet' = 0.48,
                          'verdana' = 0.63,
                          0.54)
    font.asp
}


setMarginsForAxis <- function(margins, labels, axis)
{
    if (!is.character(labels) && !is.null(labels$labels))
        labels <- labels$labels
    lab.len <- 0
    lab.nline <- 0
    lab.nchar <- 1

    lab.nchar <- max(c(0, nchar(unlist(strsplit(split="<br>", as.character(labels))))), na.rm = TRUE)
    font.asp <- fontAspectRatio(axis$tickfont$family)
    lab.len <- font.asp * axis$tickfont$size * lab.nchar * 1.25
    lab.nline <- if (is.character(labels)) max(0, sapply(gregexpr("<br>", labels),
                     function(x){sum(x > -1)}), na.rm = TRUE)
                 else 0

    new.margin <- 0
    if (lab.len > 2 || (!is.null(lab.nline) && lab.nline > 0))
        new.margin <- lab.len

    title.nline <- 0
    if (sum(nchar(axis$title)) > 0 && axis$title != " ")
        title.nline <- sum(gregexpr("<br>", axis$title)[[1]] > -1) + 1
    title.pad <- max(0, axis$title$font$size) * title.nline * 1.25

    if (axis$side == "right")
        margins$r <- max(margins$r, new.margin + title.pad)
    else if (axis$side == "left")
        margins$l <- max(margins$l, new.margin + title.pad)
    else if (axis$side == "bottom")
    {
        # tickangle is changed in function setAxis
        lab.nchar <- max(c(0,nchar(unlist(strsplit(split = "<br>", as.character(labels))))), na.rm = TRUE)
        if (is.null(axis$tickangle))
            axis$tickangle <- 0
        if (axis$tickangle != 0)
            margins$b <- margins$b + 0.65 * new.margin + title.pad
        else
            margins$b <- margins$b + 1.25 * axis$tickfont$size*(floor(lab.nline)+1) + title.pad
    }
    return(margins)
}

setMarginsForText <- function(margins, title, subtitle, footer,
                        title.font.size, subtitle.font.size, footer.font.size)
{
    title.nline <- 0
    if (nchar(title) > 0)
    {
        title.nline <- sum(gregexpr("<br>", title)[[1]] > -1) + 1
        margins$t <- margins$t + (title.font.size * title.nline * 1.25)
    }
    if (nchar(subtitle) > 0)
    {
        # We leave twice the space for subtitles, because titles are always
        # positioned halfway down the top margin
        subtitle.nline <- sum(gregexpr("<br>", subtitle)[[1]] > -1) + 1.5
        margins$t <- margins$t + (subtitle.font.size * subtitle.nline) * 0.8 * 2
    }
    if (nchar(footer) > 0 && footer != " ")
    {
        footer.nline <- sum(gregexpr("<br>", footer)[[1]] > -1) + 4
        margins$b <- margins$b + (footer.font.size * footer.nline * 1.25)
    }
    margins
}

setMarginsForLegend <- function(margins, showlegend, legend, text, 
                                type = "", right.axis = FALSE)
{
    if (showlegend && legend$x > 0.99)
    {
        # Needed to preserve subtitle alignment
        if (is.factor(text))
            text <- levels(text)
        len <- max(c(0,nchar(unlist(strsplit(split = "<br>", text)))), na.rm = TRUE)
        margins$r <- min(300, 70 + (legend$font$size * max(0, len) * 0.7))
    } else if (type != "radar" && !right.axis)
        margins$r <- 20
    margins
}

setCustomMargins <- function(margins, margin.top, margin.bottom, margin.left,
    margin.right, margin.inner.pad)
{
    if (!is.null(margin.top))
        margins$t <- margin.top
    if (!is.null(margin.bottom))
        margins$b <- margin.bottom
    if (!is.null(margin.left))
        margins$l <- margin.left
    if (!is.null(margin.right))
        margins$r <- margin.right
    if (!is.null(margin.inner.pad))
        margins$pad <- margin.inner.pad
    margins
}


setTitle <- function(title, title.font, margins)
{
    if (sum(nchar(title)) == 0)
        return(NULL)
    return(list(text = title, font = title.font,
                xref = "paper", x = 0.5, yshift = margins$t * 0.5,
                yref = "paper", y = 1.0, yanchor = "middle", showarrow = FALSE))
}

setSubtitle <- function(subtitle, subtitle.font, margins)
{
    if (sum(nchar(subtitle)) == 0)
        return(NULL)
    return(list(text = subtitle, font = subtitle.font,
                xref = "paper", x = 0.5, #xshift = (margins$r - margins$l)/2,
                yref = "paper", y = 1.0, yanchor = "bottom", showarrow = FALSE))
}

setFooter <- function(footer, footer.font, margins)
{
    if (sum(nchar(footer)) == 0)
        return(NULL)

    footer.nline <- sum(gregexpr("<br>", footer)[[1]] > -1) + 1
    footer.npad <- max(0, ceiling(margins$b/footer.font$size/1.25) - footer.nline - 2)
    footer <- paste0("&nbsp;", paste(rep("<br>", footer.npad), collapse = ""), footer)
    return(list(text = footer, font = footer.font,
                xref = "paper", x = 0.5, yref = "paper", y = 0.0,
                yanchor = "top", xanchor = "center", showarrow = FALSE))
}

# This differs from as.numeric in that it returns NULL
# instead of NA if there is no valid output
# Also so basic substitution such as removing commas
charToNumeric <- function(x)
{
    if (!is.character(x))
        return(x)
    if (length(x) == 0 || is.na(x))
        return(NULL)
    if (nchar(x) == 0)
        return(NULL)

	x.orig <- x
    x <- gsub(" ", "", x)
    x <- gsub(",", "", x) # e.g. '5,000'
    xnum <- suppressWarnings(as.numeric(x))
    xnum <- xnum[!is.na(xnum)]
    if (length(xnum) != 1)
	{
		warning("Value '", x.orig, "' is not numeric.")
        return(NULL)
	}
    return(xnum)
}

# Modified warning message
charToDate <- function(x)
{
	x <- as.character(x)
    if (length(x) == 0 || is.na(x))
        return(NULL)
    if (nchar(x) == 0)
        return(NULL)

	res <- AsDate(x, on.parse.failure = FALSE)
	if (any(is.na(res)))
		warning("Value '", x, "' could not be parsed as a date.")
	return(res)
}

charToDateTime <- function(x)
{
	x <- as.character(x)
	res <- AsDateTime(x, on.parse.failure = FALSE)
	if (any(is.na(res)))
		warning("Value '", x, "' could not be parsed as a date.")
	return(res)
}

isBlank <- function(x)
{
    if (is.null(x))
        return(TRUE)
    if (is.na(x))
        return(TRUE)
    if (x == "")
        return(TRUE)
    return(FALSE)
}

# This is only applied to the values axis.
# It can handle categorical and date axes types but only for the values axis
# (date categorical axis range is set using getDateAxisRange in setAxis)
setValRange <- function(min, max, values, show.zero = FALSE, use.defaults = TRUE, is.bar = FALSE)
{
    if (is.null(min) || is.na(min) || min == "")
        min <- NULL
    if (is.null(max) || is.na(max) || max == "")
        max <- NULL

    # If no range is specified, then use defaults
    if (use.defaults && is.null(min) && is.null(max))
        return(list(min = NULL, max = NULL))

    if (is.list(values) && !is.null(values$labels.on.x))
    {
        axis.type <- if (values$labels.on.x) values$x.axis.type else values$y.axis.type
        if (axis.type == "date")
            values <- values$ymd
        else if (axis.type %in% c("numeric", "linear"))
            values <- suppressWarnings(as.numeric(values$labels))
        else
            values <- 0:(length(values$labels)-1)
    }

    if (is.factor(values) || is.character(values))
        values <- as.numeric(as.factor(values)) - 1
    if (inherits(values, "POSIXct"))
    {
		if (!is.null(min) && !is.na(min))
			min <- charToDateTime(min)
		if (!is.null(max) && !is.na(max))
			max <- charToDateTime(max)

    } else if (inherits(values, "Date") || inherits(values, "POSIXct"))
    {
		if (!is.null(min) && !is.na(min))
			min <- charToDate(min)
		if (!is.null(max) && !is.na(max))
			max <- charToDate(max)

    } else
    {
        min <- charToNumeric(min)
        max <- charToNumeric(max)
    }

    if  (length(min) == 0 || is.na(min))
        min <- min(unlist(values), if (show.zero) 0 else NULL, na.rm = TRUE)
    if  (length(max) == 0 || is.na(max))
        max <- max(unlist(values), na.rm = TRUE)

    if (is.bar && length(values) > 1)
    {
        diff <- min(diff(values))/2
        min <- min - diff
        max <- max + diff
    }
    return(list(min = min, max = max))
}


setTicks <- function(minimum, maximum, distance, reversed = FALSE,
                data = NULL, labels = NULL, type="scatter", label.font.size = 10, is.bar = FALSE)
{
    #if (is.null(minimum) != is.null(maximum))
    #    warning("To specify the range of an axis, you must specify both the minimum and maximum values.")
    if ((is.null(minimum) || is.null(maximum)) && !is.null(distance))
        stop("If specifying the distance between ticks on an axis,",
             "you must also specify the minimum and maximum values.")

    # starting values
    mode <- "auto"
    range <- NULL
    tickvals <- NULL
    ticktext <- NULL
    autorange <- TRUE

    if (reversed)
        autorange <- "reversed"

    if (!is.null(data))
    {
        is.bar <- grepl("Bar", type) && !grepl("Stacked", type)
        if (is.null(minimum))
            minimum <- min(0, min(data, na.rm = TRUE))
        if (is.null(maximum))
            maximum <- max(data, na.rm = TRUE)

        # Add horizontal space for data labels in bar charts
        pad <- 0
        lab.len <- 1
        if (!is.null(labels) && is.bar)
        {
            lab.len <- max(nchar(as.character(unlist(labels))))
            pad <- (maximum - minimum) * (lab.len+2) * label.font.size / 200
        }
        if (!is.bar || min(data, na.rm = TRUE) < 0)
            minimum <- minimum - pad
        maximum <- maximum + pad
    }

    if (!is.null(minimum) && !is.null(maximum))
    {
        autorange <- FALSE
        range <- c(minimum, maximum)
        if (reversed)
            range <- rev(range)
    }
    if (!is.null(distance) && is.numeric(minimum) && is.numeric(maximum))
    {
        # error msg if axis is not numeric
        autorange <- FALSE
        mode <- "array"
        if (is.bar && distance == round(distance))
        {
            minimum <- ceiling(minimum)
            maximum <- floor(maximum)
        }
        tickvals <- seq(minimum, maximum, by=distance)
    }
    return (list(autorange=autorange, mode=mode, range=range,
                 tickvals=tickvals, ticktext=ticktext))
}

## Takes a matrix, and returns a matrix of either a cumulative sum,
## or a cumulative sum of percentages, over each row.
cum.data <- function(x, output = "cumulative.percentage")
{
    result <- if (output == "cumulative.sum")
        apply(x, 1, function(z) cumsum(z))
    else if (output == "cumulative.percentage")
        apply(x, 1, function(z) cumsum(prop.table(z)))
    else if (output == "column.percentage")
        apply(x, 1, function(z) prop.table(z))
    t(result)
}

cum.signed.data <- function(x)
{
    result <- matrix(0, NROW(x), NCOL(x))
    for (i in 1:nrow(x))
    {
        ind <- which(x[i,] >= 0)
        if (length(ind) > 0)
            result[i,ind] <- cumsum(x[i,ind])

        ind <- which(x[i,] < 0)
        if (length(ind) > 0)
            result[i,ind] <- cumsum(x[i,ind])
    }
    return(result)
}

## Takes a single string and puts <br> in place of the closest space preceding the n= value character.
## E.g. if n= 20 then count 20 characters.  The space preceding character 20 is replaced by "<br>".
lineBreakEveryN <- function(x, n = 21, remove.empty)
{
    if (n <= 0)
        stop("Wrap line length cannot be smaller than 1")

    w.list <- strsplit(x, " ")[[1]]
    if (remove.empty)
        w.list <- w.list[which(nchar(w.list) > 0)]
    if (length(w.list) == 0)
        return(" ")
    final <- w.list[1]
    c.len <- lengthLastLine(final)
    for (ww in w.list[-1])
    {
        new.len <- c.len + nchar(ww) + 1
        if (new.len > n)
        {
            final <- paste0(final, "<br>", ww)
            c.len <- lengthLastLine(ww)
        } else if (grepl("<br>", ww))
        {
            final <- paste0(final, " ", ww)
            c.len <- lengthLastLine(ww)
        } else
        {
            final <- paste0(final, " ", ww)
            c.len <- new.len
        }
    }
    final
}

lengthLastLine <- function(x)
{
    tmp <- strsplit(x, split = "<br>")[[1]]
    return(nchar(tmp[length(tmp)]))
}

#' Format long labels for html by truncating and wrapping
#'
#' @param x Character; the text to format.
#' @param wordwrap Logical; whether line breaks ('<br>') should be inserted.
#' @param n Integer; the maximum number of characters before a line breaks is added. The break is added at the nearest word boundary.
#' @param truncate Logical; whether long labels should be truncated and appended with '...' instead.
#' @param remove.empty Logical; whether to remove zero-length strings 
#' @export
autoFormatLongLabels <- function(x, wordwrap = FALSE, n = 21, truncate = FALSE, remove.empty = TRUE)
{
    if (truncate)
        warning("autoFormatLongLabels: truncate not longer does anything.")
    if (is.null(x))
        return("")
    if (!is.character(x))
        x <- as.character(x)

    # Check for zero-length strings which are ignored by plotly
    if (length(x) > 1)
    {
        ind <- which(sapply(x, nchar) == 0)
        if (length(ind) > 0)
            x[ind] <- " "
    }

    output.text <- x
    if (wordwrap && length(output.text) > 0)
        output.text <- sapply(output.text, function(x) lineBreakEveryN(x, n, remove.empty = remove.empty))
    if (length(output.text) == 0 || all(is.na(output.text)))
        output.text <- ""

    attributes(output.text) <- NULL
    output.text
}

stripClassAndCallFromXtabs <- function(chart.matrix)
{
    if (class(chart.matrix) == "xtabs" || class(chart.matrix) == "table")
    {
        attr(chart.matrix, "class") <- NULL
        attr(chart.matrix, "call") <- NULL
        return(chart.matrix)
    }
    else
        return(chart.matrix)
}

decimalsToDisplay <- function(x)
{
    mx <- max(x, na.rm = TRUE)
    mn <- min(x, na.rm = TRUE)
    rng <- max(c(mx - mn, abs(mx), abs(mn)))
    if (!is.na(rng) && rng > 0)
        max(-floor(log10(rng)) + 1, 0)
    else
        NULL
}

#' Force evaluation of variables in an environment
#'
#' Used by some plotting functions before calling Distribution
#' important for unit testing with testthat.
#' Also evaluates variables that have been assigned
#' another variable in the signature (relevant if
#' try eval(cl, parent.frame()) )
#' @noRd
#' @param x Component of a \code{\link{call}}
#' @param env Environment to evaluate \code{x} in
#' @return \code{x} or if it has class \code{"name"}
#' or \code{"call"}, its value when evaluated in \code{env}.
evalc <- function(x, env)
{
    if (inherits(x, c("name", "call")))
        return(eval(x, env))
    x
}

#' Extract the number of decimal places from a d3 format string.
#'
#' All chart functions should accept d3 formats. This is used by functions
#' that do not handle d3 to find the number of decimal places used to
#' format labels and hovertext.
#' #' @noRd
#' @param format d3 formatting string
#' @param default The number of decimal places if \code{format} is
#' not provided (usually signifying automatic formatting).
#' @return integer
decimalsFromD3 <- function(format, default = 0)
{
    if (length(format) == 0 || format == "")
        return(default)
    return(sum(as.numeric(regmatches(format, regexpr("\\d+", format)))))
}

#' Whether to format as percentages based on a d3 format string.
#'
#' All chart functions should accept d3 formats. This is used by functions
#' that do not handle d3 to determine whether to format labels and hovertext as percentages.
#' #' @noRd
#' @param format d3 formatting string
#' @return logical
percentFromD3 <- function(format)
{
    return(substr(format, nchar(format), nchar(format)) == "%")
}

#' Output data in D3-formatting
#'
#' Returns a strings according to the d3 format specified.
#' @noRd
#' @param x Input data (may be a vector) to format
#' @param format D3 formatting string. Accepts percentages, numeric and scientific notation
#' @param prefix Optional string to prepend to output
#' @param suffix Optional string to append to output
#' @param decimals Default number of decimals shown; used if not specified in \code{format}
formatByD3 <- function(x, format, prefix = "", suffix = "", percent = FALSE, decimals = 2)
{
    x.str <- as.character(x)
    if (format == "Category")
        return(x.str)
    if (is.numeric(x))
    {
        use.comma <- commaFromD3(format) || format == ""
        big.mark <- if (use.comma) "," else ""
        tmp.fmt <- gsub("[^deEfgGs]", "", format)
        tmp.fmt <- gsub("s", "g", tmp.fmt) # switch d3 SI-prefix format to scientific 

        if (percentFromD3(format) || percent)
            x.str <- paste0(formatC(x*100, format = "f", digits = decimalsFromD3(format, 0), big.mark = big.mark), "%")
        else if (sum(nchar(tmp.fmt), na.rm = T) == 0 || tmp.fmt == "f")
            x.str <- FormatAsReal(x, decimals = decimalsFromD3(format, decimals), comma.for.thousands = use.comma)
        else
            x.str <- formatC(x, format = tmp.fmt, digits = decimalsFromD3(format, decimals), big.mark = big.mark)
    }
    if (inherits(x, "Date") || inherits(x, "POSIXct") || inherits(x, "POSIXt"))
        x.str <- format(x, format)
    x.str <- paste0(prefix, x.str, suffix)
    return(x.str)
}

#' Whether to format numbers with comma separation of thousands based on a d3 format string.
#'
#' All chart functions should accept d3 formats. This is used by functions
#' that do not handle d3 to determine how to format labels and hovertext.
#' #' @noRd
#' @param format d3 formatting string
#' @return logical
commaFromD3 <- function(format)
{
    return(grepl(",", format, fixed = TRUE))
}


# Gives a warning if the axis.type is incompatible
# Will also specify a numeric format if none is supplied
# convert is only used by LabeledScatter
checkD3Format <- function(format, axis.type, warning.type = "Axis label", convert = FALSE)
{
    # This is to avoid LabeledScatter's problem with date formatting
    if (convert && axis.type == "date" && sum(nchar(format), na.rm = TRUE) == 0)
        return("%b %d %Y")

    if (sum(nchar(format), na.rm = TRUE) == 0)
        return("")
    if (substr(format, nchar(format), nchar(format)) %in% c("", 0:9)) # automatic formatting
    {
        if (axis.type == "numeric")
            return(paste0(format, "f"))
        else
            return(format)
    }
    mismatch <- FALSE
    if (d3FormatType(format) != axis.type)
    {
        warning(warning.type, " format of type '", d3FormatType(format),
                "' incompatible with axis type '", axis.type, "'")
        mismatch <- TRUE
    }
    if (convert && axis.type == "date" && d3FormatType(format) != axis.type)
        return("%b %d %Y")
    if (mismatch)
        return ("")
    return(format)
}

notAutoRange <- function(axis)
{
    return(!isTRUE(axis$autorange) && length(axis$range) > 0 && min(abs(axis$range)) > 0)
}

getSign <- function(values, axis)
{
    res <- sign(values)
    if (any(is.na(res)))
        res[which(is.na(res))] <- 0
    if (length(axis$range) >= 2 && axis$range[2] < axis$range[1])
        res <- -res
    else if (axis$autorange == "reversed")
        res <- -res
    return(res)
}

#' use black or white for good contrast against colors
#'
#' @param colors vector of colors which will be the background color of the
#' @importFrom grDevices col2rgb rgb2hsv
autoFontColor <- function (colors)
{
    tmp.rgb <- col2rgb(colors)
    tmp.lum <- apply(tmp.rgb, 2, function(x) return(0.299*x[1] + 0.587*x[2] + 0.114*x[3]))
    return(ifelse(tmp.lum > 126, "#2C2C2C", "#FFFFFF"))
}

vectorize <- function(x, n, split = ",")
{
    if (is.logical(x))
        return(suppressWarnings(rep(TRUE, n) & x))

    if (is.numeric(x))
        return(suppressWarnings(rep(0, n) + x))

    if (!is.null(split))
        x <- TextAsVector(x, split = split)
    return(suppressWarnings(paste0(x, rep("", n))))
}

addDataLabelAnnotations <- function(p, type, name, data.label.xpos, data.label.ypos, 
        data.label.text, data.label.sign, annotation.list, annot.data, i,
        xaxis, yaxis, data.label.font, is.stacked, data.label.centered)
{
    if (type == "Column")
    {
        if (is.stacked)
            data.label.sign <- -1 * data.label.sign
        if (is.stacked && data.label.centered)
            textalign <- "middle center"
        else
            textalign <- ifelse(data.label.sign >= 0, "top center", "bottom center")
        data.label.pos <- ifelse(data.label.sign < 0, 3, 0 + (is.stacked & !data.label.centered))
    } else
    {
        textalign <- if (is.stacked) "middle center"
                     else            ifelse(data.label.sign >= 0, "middle right", "middle left")
        data.label.pos <- if (is.stacked) 0
                          else            ifelse(data.label.xpos < 0, 7, 3) 
    }

    n <- length(data.label.xpos)
    data.label.nchar <- nchar(data.label.text) # get length before adding html tags
    max.diam <- 0
    # add arrow and text annotations as a prefix/suffix to existing data labels
    for (j in seq_along(annotation.list))
    {
        a.tmp <- annotation.list[[j]]
        if (!is.null(a.tmp$threshold))
        {
            # Convert string to numeric where possible - otherwise string comparison will be used
            tmp.thres <- suppressWarnings(as.numeric(a.tmp$threshold))
            if (!is.na(tmp.thres))
            {
                a.tmp$threshold <- tmp.thres
                annotation.list[[j]]$threshold <- tmp.thres
            }
        }
        if (grepl("Circle", a.tmp$type))
        { 
            if (a.tmp$type != "Circle - filled")
            {
                a.tmp$size <- a.tmp$size + 5
                annotation.list[[j]]$size <- a.tmp$size
            }   
            if (a.tmp$size > max.diam)
                max.diam <- a.tmp$size + 0.01
        } else
        {
            tmp.dat <- getAnnotData(annot.data, a.tmp$data, i, as.numeric = !grepl("Text", a.tmp$type))
            ind.sel <- if (is.null(a.tmp$threstype) || is.null(a.tmp$threshold))    1:n
                       else if (a.tmp$threstype == "above threshold")               which(tmp.dat > a.tmp$threshold)
                       else                                                         which(tmp.dat < a.tmp$threshold)
            
            all.annot.types <- c('Arrow - up', 'Arrow - down', 'Border', 
                        'Circle - filled', 'Circle - thick outline', 'Circle - thin outline',
                        'Hide', 'Shadow', 'Text - after data label', 'Text - before data label')   
            if (!a.tmp$type %in% all.annot.types)
            {
                warning("Unknown annotation type: '", a.tmp$type, "'. ",
                        "Valid types are '", paste(all.annot.types, collapse = "', '"), "'.")
                return(p)
            }
            data.label.text[ind.sel] <- addAnnotToDataLabel(data.label.text[ind.sel], a.tmp, tmp.dat[ind.sel])
        }
    }

    # Circle annotations
    for (j in seq_along(annotation.list))
    {
        a.tmp <- annotation.list[[j]]
        if (grepl("Circle", a.tmp$type))
        {
            tmp.dat <- getAnnotData(annot.data, a.tmp$data, i)
            ind.sel <- if (is.null(a.tmp$threstype) || is.null(a.tmp$threshold))    1:n
                       else if (a.tmp$threstype == "above threshold")               which(tmp.dat > a.tmp$threshold)
                       else                                                         which(tmp.dat < a.tmp$threshold)

            tmp.text <- rep("", n)
            left.pad <- paste(rep(" ", sum(a.tmp$shiftright, na.rm = TRUE)), collapse = "")
            right.pad <- paste(rep(" ", sum(a.tmp$shiftleft, na.rm = TRUE)), collapse = "")
            tmp.text[ind.sel] <- paste0(left.pad, switch(a.tmp$type, 
                "Circle - thick outline" = "<b>&#11096;</b>", 
                "Circle - thin outline" = "&#11096;", 
                "Circle - filled" = "&#11044;"), right.pad)
            tmp.font <- list(family = data.label.font$family, color = a.tmp$color, size = a.tmp$size)

            # Adjusting circle position
            tmp.pos <- 0.01         # setting to 0 will result in default = 3 being used
            if (!is.stacked)
                tmp.pos <- max(0.01, (max.diam - a.tmp$size))
            if (type == "Bar" && !is.stacked)
                tmp.pos <- tmp.pos + (data.label.nchar * data.label.font$size * 0.3)
            if (type == "Column" && !is.stacked)
                tmp.pos <- tmp.pos + (data.label.sign < 0) * 5
            
            p <- add_trace(p, x = data.label.xpos, y = data.label.ypos, cliponaxis = FALSE,
                  type = "scatter", mode = "markers+text", 
                  text = tmp.text, textfont = tmp.font,
                  marker = list(opacity = 0.0, color = "red", size = tmp.pos),
                  xaxis = xaxis, yaxis = yaxis,
                  textposition = textalign, 
                  showlegend = FALSE, hoverinfo = "skip",
                  legendgroup = if (is.stacked) "all" else i)
        }
    }

    # Add data annotations
    tmp.offset <- if (!is.stacked) max(0, (max.diam - data.label.font$size))
                  else             0.01
    data.label.pos <- data.label.pos + tmp.offset
    p <- add_trace(p, name = name,
              x = data.label.xpos, y = data.label.ypos, cliponaxis = FALSE,
              type = "scatter", mode = "markers+text", 
              marker = list(opacity = 0.0, size = data.label.pos),
              xaxis = xaxis, yaxis = yaxis,
              text = data.label.text, textfont = data.label.font,
              textposition = textalign, showlegend = FALSE, hoverinfo = "skip",
              legendgroup = if (is.stacked) "all" else i)

}

getColumn <- function(x, i)
{
    if (length(dim(x)) == 2)
        return(x[,i,drop = FALSE])
    if (length(dim(x)) == 3)
        return(x[,i, , drop = FALSE])
}

getAnnotData <- function(data, name, series, as.numeric = TRUE)
{
    if (is.null(data))
        stop("No data has been provided for annotations")
    if (is.null(dim(data)))
        data <- as.matrix(data)
    
    d.dim <- dim(data)
    d.len <- length(d.dim)
    d.names <- dimnames(data)[[d.len]]
    if (is.null(d.names))
        d.names <- as.character(1:d.len)
    ind <- match(paste0("", name), d.names)
    if (is.na(ind))
        stop("Annotation data does not contain a statistic named '", name, "'. ",
                "Allowable names are: '", paste(d.names, collapse = "', '"), "'. ")
    if (length(d.dim) == 3)
        new.dat <- data[,series, ind]
    else
        new.dat <- data[,ind]
    if (as.numeric)
        new.dat <- as.numeric(new.dat)
    return(new.dat)
}

addAnnotToDataLabel <- function(data.label.text, annotation, tmp.dat)
{
    if (annotation$type == "Shadow")
        data.label.text <- paste0("<span style='text-shadow: 1px 1px ",
            annotation$size, "px ", annotation$color, ", -1px -1px ", 
            annotation$size, "px ", annotation$color, ";'>", data.label.text, "</span>")
    else if (annotation$type == "Border")
        data.label.text <- paste0("<span style='outline: ", annotation$width, "px solid ",
            annotation$color, "; outline-offset: ", annotation$offset, "px;'>", data.label.text, "</span>")
    else
    {
        new.style <- ""
        if (!is.null(annotation$color))
            new.style <- paste0(new.style, "color:", annotation$color, ";")
        if (!is.null(annotation$size))
            new.style <- paste0(new.style, "font-size:", annotation$size, ";")
        if (!is.null(annotation$font.family))
            new.style <- paste0(new.style, "font-family:", annotation$font.family, ";")
        if (!is.null(annotation$font.weight))
            new.style <- paste0(new.style, "font-weight:", annotation$font.weight, ";")
        if (!is.null(annotation$font.style))
            new.style <- paste0(new.style, "font-style:", annotation$font.style, ";")
        
        new.text <- ""
        if (annotation$type == "Arrow - up")
            new.text <- "&#129049;"
        else if (annotation$type == "Arrow - down")
            new.text <- "&#129051;"
        else if (grepl("Text", annotation$type))
            new.text <- formatByD3(tmp.dat, annotation$format, annotation$prefix, annotation$suffix)
        else if (annotation$type == "Hide")
            new.text <- ""

        if (nchar(new.style) > 0)
            new.text <- paste0("<span style='", new.style, "'>", new.text, "</span>")

        if (annotation$type == "Hide")
            data.label.text <- ""
        else if (annotation$type == "Text - before data label")
            data.label.text <- paste0(new.text, data.label.text)
        else
            data.label.text <- paste0(data.label.text, new.text)
    }
    return(data.label.text)
}

readLineThickness <- function(line.thickness, n)
{
    if (is.character(line.thickness))
    {
        tmp.txt <- TextAsVector(line.thickness)
        line.thickness <- suppressWarnings(as.numeric(tmp.txt))
        na.ind <- which(is.na(line.thickness))
        if (length(na.ind) == 1)
            warning("Non-numeric line thickness value '", tmp.txt[na.ind], "' was ignored.")
        if (length(na.ind) > 1)
            warning("Non-numeric line thickness values '",
            paste(tmp.txt[na.ind], collapse = "', '"), "' were ignored.")
    }
    line.thickness <- suppressWarnings(line.thickness * rep(1, n)) # suppress warnings about recyling
    return(line.thickness)
}
