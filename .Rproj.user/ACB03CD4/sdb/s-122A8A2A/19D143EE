{
    "collab_server" : "",
    "contents" : "### Required colour vector\nqColors <- c(grDevices::rgb(91, 155, 213, 255, max = 255), # blue\n             grDevices::rgb(237, 125, 49, 255, max = 255), # orange\n             grDevices::rgb(165, 165, 165, 255, max = 255), # grey\n             grDevices::rgb(30, 192, 0, 255, max = 255), # yellow\n             grDevices::rgb(68, 114, 196, 255, max = 255), # darker blue\n             grDevices::rgb(112, 173, 71, 255, max = 255), # green\n             grDevices::rgb(37, 94, 145, 255, max = 255), # even darker blue\n             grDevices::rgb(158, 72, 14, 255, max = 255), # blood\n             grDevices::rgb(99, 99, 99, 255, max = 255), # dark grey\n             grDevices::rgb(153, 115, 0, 255, max = 255), # brown\n             grDevices::rgb(38, 68, 120, 255, max = 255), # very dark blue\n             grDevices::rgb(67, 104, 43, 255, max = 255), # darker green\n             grDevices::rgb(255, 255, 255, 255, max = 255), # black\n             grDevices::rgb(255, 35, 35, 255, max = 255)) # red\n\nplotlySymbols <- plotlySymbols <- c(0,100,200,300,1,101,201,301,2,102,202,302,3,103,203,303,4,104,204,304,5,105,205,305,6,106,206,306,7,107,207,307,8,108,208,308,9,109,209,309,10,110,210,310,11,111,211,311,12,112,212,312,13,113,213,313,14,114,214,314,15,115,215,315,16,116,216,316,17,117,217,317,18,118,218,318,19,119,219,319,20,120,220,320,21,121,221,321,22,122,222,322,23,123,223,323,24,124,224,324,25,125,26,126,27,127,28,128,29,129,30,130,31,131,32,132,33,133,34,134,35,135,36,136,37,137,38,138,39,139,40,140,41,141,42,142,43,143,44,144)\n\n######################## Auxiliary functions\n## Strips out any capital X followed by a digit, as this is R-imposed in case of numeric row or col names.\nclean.numeric.labels <- function(labels) {\n    labels <- gsub(\"^X\",\"\",labels)\n    return(labels)\n}\n\n### KNOWN ISSUES TO SOLVE:\n# The function \"clean.numeric.labels\" needs to allow for text variable names that begin with X but which\n# are not otherwise entirely numeric.  e.g. \"Xylophone\", \"Xenophon\", \"X1Z\", where the INTENT was to have\n# the \"X\" and it hasn't been automatically added by Q.  Needs to compare against the original data file\n# import to be truly accurate and not make too many guesses.\n\n## Takes a matrix, and returns a matrix of either a cumulative sum, or a cumulative sum of percentages.\ncum.data <- function(x, output = \"cumulative.percentage\") {\n    if (output == \"cumulative.sum\"){\n        x <- apply(x, 2, function(z) {cumsum(z)})\n    } else if (output == \"cumulative.percentage\") {\n        x <- apply(x, 2, function(z) {cumsum(prop.table(z))})\n    } else if (output == \"column.percentage\") {\n        x <- apply(x, 2, function(z) {prop.table(z)})\n    }\n\n    return(x)\n}\n\n## Function to return number format string and potential y-axis prefix\nprintFormat <- function (tick.format = c(\"%\", \"0\"))     # Uses above to set pre-specified formats, can be:  \"n\" (number), \"%\", \"$\", \"£\", \"€\" second value is number of decimals for rounding, default = 0\n{\n    tickformat <- character()\n    if (length(tick.format) != 2)\n        tickformat[2] <- \"0\"\n\n    if (tick.format[1] == \"%\")\n    {\n        tickformat <- paste(\".\", as.integer(tick.format[2]), \"p\", sep=\"\")\n        tick.prefix <- \"\"\n    }\n    else if (tick.format[1] == \"$\" || tick.format[1] == \"£\")\n    {\n        tickformat <- paste(\".\", as.integer(tick.format[2]), \"r\", sep=\"\")\n        tick.prefix <- tick.format[1]\n    }\n    else if (tick.format[1] == \"n\")\n    {\n        tickformat <- paste(\".\", as.integer(tick.format[2]), \"r\", sep=\"\")\n        tick.prefix <- \"\"\n    }\n\n    return(c(tickformat,tick.prefix))\n}\n\n# Checks if all three vars have data, and if the first is greater than the second\ncheckBounds <- function(min, max, maj)\n{\n    if (!is.null(min) & !is.null(max) & !is.null(maj) & max > min)\n        TRUE\n\n    FALSE\n}\n\n################################################################################################\n\n## Sorts rows of a matrix in descending order (high to low) based on overall mean of each row.\n#' @export\nMeanRowValueDescendingSort <- function(x) {\n    means <- apply(x, 1, function(z) {mean(z)})\n    x <- cbind(x, means)\n    x <- x[order(-means),]\n    x <- x[,1:(ncol(x)-1)]\n    return(x)\n}\n\n## Sorts rows of a matrix in descending alphabetical order\n#' @export\nAlphabeticRowNames <- function(x, desc = TRUE) {\n    x <- x[order(rownames(x), decreasing = desc),]\n    return(x)\n}\n\n## Gives a named-elements vector of colours for each row in a matrix,\n## where the base colour is specified, and the alpha value gradually\n## increases based on the row-mean of the matrix (darker = higher),\n## and where the colour vector is returned sorted alphabetically\n#' @export\nMakeColorGradient <- function (x, red, green, blue) {\n    col.vector <- \"\"\n    number.rows <- nrow(x) + 1\n\n    for (i in 1:nrow(x)){\n        red.factor <- ((255 - red) / number.rows) * i\n        green.factor <- ((255 - green) / number.rows) * i\n        blue.factor <- ((255 - blue) / number.rows) * i\n\n        col.vector <- c(col.vector, grDevices::rgb(red + red.factor, green + green.factor, blue + blue.factor, 255, max = 255))\n    }\n\n    ## Sort the matrix by mean\n    ordered.matrix <- MeanRowValueDescendingSort(x)\n\n    ## Assign matrix row names to col.vector\n    col.vector <- col.vector[2:length(col.vector)]\n    names(col.vector) <- rownames(ordered.matrix)\n\n    ## Sort the colour vector\n    col.vector <- AlphabeticRowNames(as.matrix(col.vector))\n\n    return(col.vector)\n}\n\n#' @export\nAreaChart <-   function(y,\n                         x = NULL,\n                         # weights = NULL,                                 ## Gets passed to AsChartMatrix <- add to that function first!\n                         # subset = NULL,                                  ## Gets passed to AsChartMatrix <- add to that function first!\n                         transpose = FALSE,                                ## Should the inputs be transposed; TRUE or FALSE\n                         aggregate.period = \"month\",                       ## can be month, quarter, year\n                         y.labels = NULL,                                  ## Optional, overrides named vectors et c.\n                         x.labels = NULL,                                  ## Optional\n                         type = \"Area\",                                    ## Type of char; can be \"Area\", \"Stacked Area\", or \"100% Stacked Area\"\n                         title = \"\",                                       ## Chart title\n                         colors = qColors,                                 ## Vector of colors in RGB format\n                         transparency = 0.4,                               ## Transparency of area fill colors\n                         chart.fill.color = rgb(255, 255, 255, max = 255), ## Chart (borders around plot) background color\n                         chart.fill.transparency = 1,                      ## Chart (borders around plot) background color transparency\n                         plot.fill.color = rgb(255, 255, 255, max = 255),  ## Plot (the plot area proper) background color\n                         plot.fill.transparency = 1,                       ## Plot (the plot area proper) background color transparency\n                         legend.show = TRUE,                               ## Show the legend, TRUE or FALSE\n                         legend.fill = rgb(255, 255, 255, max = 255),      ## Legend fill color\n                         legend.border.color = rgb(44, 44, 44, max = 255), ## Legend border color\n                         legend.border.line.width = 0,                     ## >0 means border on; width in pixels\n                         legend.font.color = rgb(44, 44, 44, max = 255),   ## Legend font color\n                         legend.font.family = \"Arial\",                     ## Legend font family.\n                         legend.font.size = 12,                            ## Legend font size\n                         legend.position = \"right\",                        ## Can be \"left\" or \"right\"\n                         legend.sort.order = \"normal\",                     ## Can be \"normal\" or \"reversed\" (see also grouping options, currently excluded from this function)\n                         margin.top = 80,                                  ## Margin between plot area and the top of the graphic\n                         margin.bottom = 80,                               ## Margin between plot area and the bottom of the graphic\n                         margin.left = 80,                                 ## Margin between plot area and the left of the graphic\n                         margin.right = 80,                                ## Margin between plot area and the right of the graphic\n                         margin.inner.pad = 0,                             ## Padding between graph proper and axis lines\n                         y.title = \"\",                                     ## Y-axis title\n                         y.title.font.color = rgb(44, 44, 44, max = 255),  ## Y-axis title font color\n                         y.title.font.family = \"Arial\",                    ## Y-axis title font family\n                         y.title.font.size = 16,                           ## Y-axis title font size\n                         y.line.width = 1,                                 ## Y-axis line in pixels, 0 = no line\n                         y.line.color = rgb(0, 0, 0, max = 255),           ## Y-axis line color\n                         y.tick.marks = \"\",                                ## Can be \"outside\", \"inside\", \"none\"\n                         y.tick.length = 5,                                ## Length in px of tick marks.\n                         y.bounds.minimum = NULL,                          ## Set minimum of range for plotting; NULL = no manual range set\n                         y.bounds.maximum = NULL,                          ## Set maximum of range for plotting; NULL = no manual range set\n                         y.bounds.units.major = NULL,                      ## Set step between minimum and maximum for plotting; NULL = no manual range set\n                         y.zero.line.width = 1,                            ## Width in pixels of zero line; 0 = no zero line shown\n                         y.zero.line.color = rgb(44, 44, 44, max = 255),   ## Color of zero line\n                         y.position = \"left\",                              ## Select y-axis position; can be \"left\" or \"right\"\n                         y.mirror = FALSE,                                 ## Mirror y-axis on other side?\n                         #y.values.reversed = FALSE,                       ## T/F - involves autorange and may be too complicated.\n                         y.grid.width = 1,                                 ## Width of y-grid lines in pixels; 0 = no line\n                         y.grid.color = rgb(225, 225, 225, max = 255),     ## Color of y-grid lines\n                         y.ticksuffix = \"\",                                ## Y-axis tick label suffix\n                         y.tickprefix = \"\",                                ## Y-axis tick label prefix\n                         y.tick.angle = 0,                                 ## Y-axis tick label angle in degrees.  90 = vertical; 0 = horizontal\n                         y.tick.format.manual = \"\",                        ## See https://github.com/mbostock/d3/wiki/Formatting#numbers or https://docs.python.org/release/3.1.3/library/string.html#formatspec\n                         y.tick.format = c(\"\",\"\"),                         ## Uses above to set pre-specified formats, can be:  \"n\" (number), \"%\", \"$\", \"£\", second value is number of total digits showing (not decimals...)\n                         y.tick.font.color = rgb(0, 0, 0, max = 255),      ## Y-axis tick label font color\n                         y.tick.font.family = \"Arial\",                     ## Y-axis tick label font family\n                         y.tick.font.size = 10,                            ## Y-axis tick label font size\n                         y.hover.format.manual = \"\",                       ## See https://github.com/mbostock/d3/wiki/Formatting#numbers or https://docs.python.org/release/3.1.3/library/string.html#formatspec\n                         y.hover.format = c(\"\",\"\"),                        ## Uses above to set pre-specified formats, can be:  \"n\" (number), \"%\", \"$\", \"£\", second value is number of total digits showing (not decimals...)\n                         x.title = \"\",                                     ## X-axis title\n                         x.title.font.color = rgb(44, 44, 44, max = 255),  ## X-axis title font color\n                         x.title.font.family = \"Arial\",\t\t\t           ## X-axis title font family\n                         x.title.font.size = 16,\t\t\t               ## X-axis title font size\n                         x.line.width = 1,                                 ## X-axis line in pixels, 0 = no line\n                         x.line.color = rgb(0, 0, 0, max = 255),\t       ## X-axis line color\n                         x.tick.marks = \"\",                                ## \"outside\", \"inside\", \"none\"\n                         x.tick.length = 5,                                ## Length in px of tick marks.\n                         x.bounds.minimum = 0,                             ## Set minimum of range for plotting; NULL = no manual range set\n                         x.bounds.maximum = 1,                             ## Set maximum of range for plotting; NULL = no manual range set\n                         x.bounds.units.major = 0.2,                       ## Set step between minimum and maximum for plotting; NULL = no manual range set\n                         x.zero.line.width = 1,                            ## Width in pixels of zero line; 0 = no zero line shown\n                         x.zero.line.color = rgb(44, 44, 44, max = 255),   ## Color of zero line\n                         x.position = \"bottom\",                            ## Select x-axis position (\"top\"/\"bottom\")\n                         x.mirror = FALSE,                                 ## Mirror x-axis on other side?\n                         #x.values.reversed = FALSE,                       ## T/F - involves autorange and may be too complicated.\n                         x.grid.width = 0,                                 ## Width of x-grid lines in pixels; 0 = no line\n                         x.grid.color = rgb(225, 225, 225, max = 255),     ## Width of y-grid lines in pixels; 0 = no line\n                         x.ticksuffix = \"\",\t\t\t\t                   ## X-axis tick label suffix\n                         x.tickprefix = \"\",\t\t\t\t                   ## X-axis tick label prefix\n                         x.tick.angle = 0,\t\t\t\t                   ## X-axis tick label angle in degrees.  90 = vertical; 0 = horizontal\n                         x.tick.format.manual = \"\",                        ## See https://github.com/mbostock/d3/wiki/Formatting#numbers or https://docs.python.org/release/3.1.3/library/string.html#formatspec\n                         x.tick.format = c(\"\",\"\"),                         ## Uses above to set pre-specified formats, can be:  \"n\" (number), \"%\", \"$\", \"£\", second value is number of total digits showing (not decimals...)\n                         x.hover.format.manual = \"\",                       ## See https://github.com/mbostock/d3/wiki/Formatting#numbers or https://docs.python.org/release/3.1.3/library/string.html#formatspec\n                         x.hover.format = c(\"\",\"\"),                        ## Uses above to set pre-specified formats, can be:  \"n\" (number), \"%\", \"$\", \"£\", second value is number of total digits showing (not decimals...)\n                         x.tick.font.color = rgb(0, 0, 0, max = 255),\t   ## Y-axis tick label font color\n                         x.tick.font.family = \"Arial\",\t\t\t           ## Y-axis tick label font family\n                         x.tick.font.size = 10,\t\t\t\t               ## Y-axis tick label font size\n                         series.marker.show = \"none\",                      ## Can be \"none\", \"automatic\" or a vector referencing the plotly symbol dictionary using either numerics or strings.\n                         series.marker.color = qColors,                    ## A vector of colors to use for the markers\n                         series.marker.transparency = 1,                   ## Transparency for series markers\n                         series.marker.size = 6,                           ## Size in pixels of marker\n                         series.marker.border.width = 1,                   ## Width in pixels of border/line around series markers; 0 is no line\n                         series.marker.border.color = qColors,             ## Color of border/line around series markers\n                         series.marker.border.transparency = 1,            ## Transparency of border/line around series markers\n                         series.line.width = 0,                            ## 0 = no line, else thickness of line for series.\n                         series.line.color = qColors,                      ## A vector of colors to use for the lines\n                         series.line.transparency = 1,                     ## Transparency for series lines\n                         hover.mode = \"closest\",                           ## Can be FALSE, \"x\", \"y\", or \"closest\"\n                         show.modebar = FALSE                              ## T/F - show the zoom menu\n)\n{\n    ## Get dependencies\n    require(plotly)\n\n    ## Make a chart matrix\n    chart.matrix <- AsChartMatrix(y, x, transpose = transpose, aggregate.period = aggregate.period)\n\n    ## Check that the chart matrix is a success\n    if (!IsChartMatrix(chart.matrix, n.rows = nrow(chart.matrix), n.columns = ncol(chart.matrix)))\n        stop(paste(\"Input data is not in a chart matrix format\"))\n\n    ## Issue warning if transparency is = 1 and type = \"Area\"\n    if (transparency == 1 && type == \"Area\")\n        warning(\"Displaying this chart without transparent series will make it difficult to read as some data series may be obscured.\")\n\n    ## Change the matrix data according to requirements of the chart type\n    if (type == \"Stacked Area\")\n        chart.matrix <- cum.data(chart.matrix, \"cumulative.sum\")\n    else if (type == \"100% Stacked Area\")\n        chart.matrix <- cum.data(chart.matrix, \"cumulative.percentage\")\n\n    ## Get axes labels from the matrix labels if none manually specified\n    if (is.null(x.labels))\n        x.labels <- clean.numeric.labels(colnames(chart.matrix))\n\n    if (is.null(y.labels))\n        y.labels <- rownames(chart.matrix)\n\n    ## Determine whether to draw to zero y (overlapping area chart) or to next y (for stacked)\n    if (type == \"Area\")\n        fill.bound <- \"tozeroy\"\n    else\n        fill.bound <- \"tonexty\"\n\n    ## Position legend\n    legend.x.anchor <- \"left\"\n    legend.y.anchor <- \"auto\"\n    legend.y <- 1\n    legend.x <- 1.02\n\n    ### If legend on right and there's a y-axis on the right too:\n    y2 = \"\"\n    if (legend.position == \"right\" && (y.mirror == TRUE || y2 != \"\" || y.position == \"right\"))\n        legend.x = 1.15\n\n    ### If legend on the left, and there's no y-axis on the left:\n    if (legend.position == \"left\" && y.position == \"right\" && y.mirror == FALSE && y2 != \"\")\n    {\n        legend.x.anchor <- \"right\"\n        legend.x <- -.02\n    }\n    else if (legend.position == \"left\")\n    {\n        legend.x.anchor <- \"right\"\n        legend.x <- -.15\n        margin.r <- 80\n    }\n\n    ## Group legend items if it's a stacked area chart as taking individual items off makes no sense\n    # legend.group <- \"\"\n    # if (type != \"Area\")\n    #     legend.group <- \"grouped\"\n\n    ## If line thickness is zero, then we shouldn't show a line; ticks only shown if there's a line (same as Excel)\n    ## Tick labels only shown if there's a line too - makes no sense either.\n    y.showline <- FALSE\n    y.showticklabels <- FALSE\n    y.showticks <- FALSE\n    if (y.line.width >= 1)\n    {\n        y.showline <- TRUE\n        y.showticklabels <- TRUE\n        # Default to outer tick marks if they are to be shown, but have not been specified\n        if (y.tick.marks == \"\")\n        {\n            y.showticks <- TRUE\n            y.tick.marks <- \"outer\"\n        }\n    }\n    else\n        y.tick.marks <- \"\"\n\n    x.showline <- FALSE\n    x.showticklabels <- FALSE\n    x.showticks <- FALSE\n    if (x.line.width >= 1)\n    {\n        x.showline <- TRUE\n        x.showticklabels <- TRUE\n        # Default to outer tick marks if they are to be shown, but have not been specified\n        if (x.tick.marks == \"\")\n        {\n            x.showticks <- TRUE\n            x.tick.marks <- \"outer\"\n        }\n    }\n    else\n        x.tick.marks <- \"\"\n\n    ## Resolve numeric tick values based on y.bounds.minimum and y.bounds.maximum, and y.bounds.units.major\n    y.tickmode = \"auto\"\n    y.tickvals = integer()\n    y.ticktext = character()\n    y.range = integer()\n    y.autorange = TRUE\n\n    y.bounds.manual <- TRUE\n    if (is.null(y.bounds.minimum) | is.null(y.bounds.maximum) | is.null(y.bounds.units.major))\n        y.bounds.manual <- FALSE\n\n    if (y.bounds.manual == TRUE)\n    {\n        y.range <- c(y.bounds.minimum, y.bounds.maximum)\n        y.autorange = FALSE\n        y.tickmode <- \"array\"\n        for (a in seq(y.bounds.minimum, y.bounds.maximum, by = y.bounds.units.major))\n        {\n            y.tickvals <- c(y.tickvals, a)\n        }\n    }\n\n    x.tickmode = \"auto\"\n    x.tickvals = integer()\n    x.ticktext = character()\n    x.range = integer()\n    x.autorange = TRUE\n\n    x.bounds.manual <- FALSE\n    if (!is.null(x.bounds.minimum) & !is.null(x.bounds.maximum) & !is.null(x.bounds.units.major))\n        x.bounds.manual <- checkBounds(x.bounds.minimum, x.bounds.maximum, x.bounds.units.major)\n\n    if (x.bounds.manual == TRUE)\n    {\n        x.range <- c(x.bounds.minimum, x.bounds.maximum)\n        x.autorange = FALSE\n        x.tickmode <- \"array\"\n        for (a in seq(x.bounds.minimum, x.bounds.maximum, by = x.bounds.units.major))\n        {\n            x.tickvals <- c(x.tickvals, a)\n        }\n    }\n\n    ## Should we draw a zero line\n    y.zero.line <- FALSE\n    if (y.zero.line.width > 0)\n        y.zero.line <- TRUE\n\n    x.zero.line <- FALSE\n    if (x.zero.line.width > 0)\n        x.zero.line <- TRUE\n\n    ## Work out number format to use.\n    if (y.tick.format.manual != \"\")\n        y.tickformat <- y.tick.format.manual\n    else if (y.tick.format[1] != \"\")\n    {\n        y.tickformat.vector <- printFormat(y.tick.format)\n        y.tickformat <- y.tickformat.vector[1]\n        y.tickprefix <- y.tickformat.vector[2]\n    }\n    else\n        y.tickformat <- \"\"\n\n\n    if (x.tick.format.manual != \"\")\n        x.tickformat <- x.tick.format.manual\n    else if (x.tick.format[1] != \"\")\n    {\n        x.tickformat.vector <- printFormat(x.tick.format)\n        x.tickformat <- x.tickformat.vector[1]\n        x.tickprefix <- x.tickformat.vector[2]\n    }\n    else\n        x.tickformat <- \"\"\n\n    ## Hover number formats\n    if (y.hover.format.manual != \"\")\n        y.hoverformat <- y.hover.format.manual\n    else if (y.hover.format[1] != \"\")\n    {\n        y.hoverformat.vector <- printFormat(y.hover.format)\n        y.hoverformat <- y.hoverformat.vector[1]\n        y.hoverprefix <- y.hoverformat.vector[2]\n    }\n    else\n        y.hoverformat <- \"\"\n\n    if (x.hover.format.manual != \"\")\n        x.hoverformat <- x.hover.format.manual\n    else if (x.hover.format[1] != \"\")\n    {\n        x.hoverformat.vector <- printFormat(x.hover.format)\n        x.hoverformat <- x.hoverformat.vector[1]\n        x.hoverprefix <- x.hoverformat.vector[2]\n    }\n    else\n        x.hoverformat <- \"\"\n\n    ## Mirror settings\n    if (y.mirror == TRUE)\n        y.mirror <- \"allticks\"\n\n    if (x.mirror == TRUE)\n        x.mirror <- \"allticks\"\n\n    ## Show plot grid?\n    y.grid.show <- FALSE\n    if (y.grid.width > 0)\n        y.grid.show <- TRUE\n\n    x.grid.show <- FALSE\n    if (x.grid.width > 0)\n        x.grid.show <- TRUE\n\n    ## Showing markers and lines\n    series.mode = \"lines+markers\"  #default = line and marker\n    if (series.line.width == 0 && series.marker.show != \"none\")\n        series.mode = \"markers\"\n\n    else if (series.line.width >= 1 && series.marker.show == \"none\")\n        series.mode = \"lines\"\n\n    else if (series.line.width == 0 && series.marker.show == \"none\")\n        series.mode = \"none\"\n\n    ## Which markers to show?\n    if (series.marker.show == \"automatic\" || series.marker.show == \"none\")\n        series.marker.symbols <- plotlySymbols\n    else if (series.marker.show != \"none\" && series.marker.show != \"automatic\")\n    {\n        if (length(series.marker.show) < 100)\n            series.marker.symbols <- rep(series.marker.show, 100)\n    }\n\n    ## Increase number of colors in color vectors such that a max of 100 are stored, in case insufficient numbers have been specified\n    colors <- rep(colors, 100/length(colors))\n    series.marker.color <- rep(series.marker.color, 100/length(series.marker.color))\n    series.marker.border.color <- rep(series.marker.border.color, 100/length(series.marker.border.color))\n    series.line.color <- rep(series.line.color, 100/length(series.line.color))\n\n    ## Initiate plotly object\n    p <- plot_ly()\n\n    ## Config options\n    p <- config(displayModeBar = show.modebar)\n\n    ## Add a trace for each row of data in the matrix\n    for (a in 1:nrow(chart.matrix))\n    {\n        y = as.numeric(chart.matrix[a,])\n        x <- x.labels\n\n        p <- add_trace(p,\n                       type = type,\n                       x = x,\n                       y = y,\n                       evaluate = TRUE,\n                       fill = fill.bound,\n                       fillcolor = toRGB(colors[a], alpha = transparency),\n                       line = list(\n                           width = series.line.width,\n                           color = toRGB(series.line.color[a], alpha = series.line.transparency)\n                       ),\n                       name = y.labels[a],\n                       # legendgroup = legend.group,\n                       ## MARKERS\n                       mode = series.mode,\n                       marker = list(\n                           size = series.marker.size,\n                           color = toRGB(series.marker.color[a], alpha = series.marker.transparency),\n                           symbol = series.marker.symbols[a],\n                           line = list(\n                               color = toRGB(series.marker.border.color[a], alpha = series.marker.border.transparency),\n                               width = series.marker.border.width\n                           )\n                       )\n        )\n    }\n\n    ## Set plotly layout styles\n    p <- layout(\n        title = title,\n        ## LEGEND\n        showlegend = legend.show,\n        legend = list(\n            bgcolor = legend.fill,\n            bordercolor = legend.border.color,\n            borderwidth = legend.border.line.width,\n            font = list(\n                color = legend.font.color,\n                family = legend.font.family,\n                size = legend.font.size\n            ),\n            xanchor = legend.x.anchor,\n            yanchor = legend.y.anchor,\n            y = legend.y,\n            x = legend.x,\n            traceorder = legend.sort.order\n        ),\n        ## Y-AXIS\n        yaxis = list(\n            title = y.title,\n            titlefont = list(\n                color = y.title.font.color,\n                family = y.title.font.family,\n                size = y.title.font.size\n            ),\n            tickfont = list(\n                color = y.tick.font.color,\n                family = y.tick.font.family,\n                size = y.tick.font.size\n            ),\n            showline = y.showline,\n            linecolor = y.line.color,\n            linewidth = y.line.width,\n            tickmode = y.tickmode,\n            tickvals = y.tickvals,\n            ticktext = y.ticktext,\n            showticklabels = y.showticklabels,\n            range = y.range,\n            ticks = y.tick.marks,\n            tickangle = y.tick.angle,\n            ticklen = y.tick.length,\n            tickcolor = y.line.color,\n            zeroline = y.zero.line,\n            zerolinewidth = y.zero.line.width,\n            zerolinecolor = y.zero.line.color,\n            tickformat = y.tickformat,\n            tickprefix = y.tickprefix,\n            ticksuffix = y.ticksuffix,\n            autorange = y.autorange,\n            side = y.position,\n            mirror = y.mirror,\n            gridwidth = y.grid.width,\n            gridcolor = y.grid.color,\n            showgrid = y.grid.show,\n            hoverformat = y.hoverformat,\n            showexponent = \"all\",\n            showtickprefix = TRUE,\n            showticksuffix = TRUE\n        ),\n        ## X-AXIS\n        xaxis = list(\n            title = x.title,\n            titlefont = list(\n                color = x.title.font.color,\n                family = x.title.font.family,\n                size = x.title.font.size\n            ),\n            tickfont = list(\n                color = x.tick.font.color,\n                family = x.tick.font.family,\n                size = x.tick.font.size\n            ),\n            showline = x.showline,\n            linecolor = x.line.color,\n            linewidth = x.line.width,\n            tickmode = x.tickmode,\n            tickvals = x.tickvals,\n            ticktext = x.ticktext,\n            showticklabels = x.showticklabels,\n            range = x.range,\n            ticks = x.tick.marks,\n            tickangle = x.tick.angle,\n            ticklen = x.tick.length,\n            tickcolor = x.line.color,\n            zeroline = x.zero.line,\n            zerolinewidth = x.zero.line.width,\n            zerolinecolor = x.zero.line.color,\n            tickformat = x.tickformat,\n            tickprefix = x.tickprefix,\n            ticksuffix = x.ticksuffix,\n            autorange = x.autorange,\n            side = x.position,\n            mirror = x.mirror,\n            gridwidth = x.grid.width,\n            gridcolor = x.grid.color,\n            showgrid = x.grid.show,\n            hoverformat = x.hoverformat,\n            showexponent = \"all\",\n            showtickprefix = TRUE,\n            showticksuffix = TRUE\n        ),\n        ## MARGINS\n        margin = list(\n            t = margin.top,\n            b = margin.bottom,\n            l = margin.left,\n            r = margin.right,\n            pad = margin.inner.pad\n        ),\n        plot_bgcolor = toRGB(plot.fill.color, alpha = plot.fill.transparency),\n        paper_bgcolor = toRGB(chart.fill.color, alpha = chart.fill.transparency),\n        hovermode = hover.mode\n    )\n\n    ## Return the chart\n    p\n}\n\n",
    "created" : 1461632771555.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1592597979",
    "id" : "19D143EE",
    "lastKnownWriteTime" : 1461908019,
    "last_content_update" : 1461908019930,
    "path" : "~/GitHub/flipStandardCharts/R/areachart.R",
    "project_path" : "R/areachart.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 6,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}